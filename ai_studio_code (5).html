<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled 3D Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #video-input { transform: scaleX(-1); position: absolute; top: 10px; left: 10px; width: 160px; height: 120px; z-index: 2; border-radius: 8px; border: 2px solid #333; opacity: 0.7; }
        #ui { position: absolute; bottom: 20px; left: 20px; color: white; z-index: 2; pointer-events: none; }
        h1 { margin: 0; font-size: 1.2rem; text-transform: uppercase; letter-spacing: 2px; }
        p { font-size: 0.8rem; opacity: 0.8; }
        .instruction { color: #00ffcc; }
    </style>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <!-- Camera Feed (Miniature) -->
    <video id="video-input"></video>
    
    <!-- 3D Scene -->
    <div id="canvas-container"></div>

    <div id="ui">
        <h1>Particle Morpher</h1>
        <p>1 Finger: <span class="instruction">Sphere</span> | 2 Fingers: <span class="instruction">Heart</span></p>
        <p>3 Fingers: <span class="instruction">Saturn</span> | 4 Fingers: <span class="instruction">Flower</span></p>
        <p>5 Fingers / Open Hand: <span class="instruction">Fireworks</span></p>
        <p>Pinch (Thumb+Index): <span class="instruction">Control Size</span></p>
    </div>

<script>
    // ==========================================
    // 1. SCENE SETUP
    // ==========================================
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    // Add fog for depth
    scene.fog = new THREE.FogExp2(0x000000, 0.002);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 50;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    // ==========================================
    // 2. PARTICLE SYSTEM
    // ==========================================
    const particleCount = 6000;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const targetPositions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    const sizes = new Float32Array(particleCount);

    const color1 = new THREE.Color(0x00ffff); // Cyan
    const color2 = new THREE.Color(0xff00cc); // Magenta

    for (let i = 0; i < particleCount; i++) {
        // Initial random positions
        positions[i * 3] = (Math.random() - 0.5) * 100;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 100;

        // Initialize targets same as current
        targetPositions[i * 3] = positions[i * 3];
        targetPositions[i * 3 + 1] = positions[i * 3 + 1];
        targetPositions[i * 3 + 2] = positions[i * 3 + 2];

        // Colors
        colors[i * 3] = color1.r;
        colors[i * 3 + 1] = color1.g;
        colors[i * 3 + 2] = color1.b;

        sizes[i] = Math.random() * 0.5;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    
    // Shader Material for cool glowing particles
    const material = new THREE.PointsMaterial({
        size: 0.8,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.8
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // ==========================================
    // 3. SHAPE GENERATORS
    // ==========================================
    
    function getSpherePoint(r) {
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1);
        return {
            x: r * Math.sin(phi) * Math.cos(theta),
            y: r * Math.sin(phi) * Math.sin(theta),
            z: r * Math.cos(phi)
        };
    }

    function getHeartPoint(scale) {
        // Parametric Heart Equation
        let t = Math.random() * Math.PI * 2;
        let x = 16 * Math.pow(Math.sin(t), 3);
        let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
        let z = (Math.random() - 0.5) * 10; // Thickness
        return { x: x * scale, y: y * scale, z: z };
    }

    function getSaturnPoint(i) {
        // 70% planet, 30% rings
        if (i < particleCount * 0.7) {
            return getSpherePoint(12);
        } else {
            // Ring
            const angle = Math.random() * Math.PI * 2;
            const distance = 18 + Math.random() * 8;
            return {
                x: Math.cos(angle) * distance,
                y: (Math.random() - 0.5) * 1, // Flat ring
                z: Math.sin(angle) * distance
            };
        }
    }

    function getFlowerPoint(i) {
        const r = 20 * Math.sqrt(Math.random());
        const theta = Math.random() * 2 * Math.PI;
        // Rose curve logic roughly
        const k = 4; // petals
        const shape = Math.cos(k * theta); 
        const x = r * Math.cos(theta) * (1 + 0.5 * shape);
        const y = r * Math.sin(theta) * (1 + 0.5 * shape);
        const z = (Math.random() - 0.5) * 5 + (shape * 5); // curve depth
        return { x: x, y: y, z: z };
    }

    function getFireworkPoint() {
        // Explosion out from center
        const r = 30 + Math.random() * 20;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        return {
            x: r * Math.sin(phi) * Math.cos(theta),
            y: r * Math.sin(phi) * Math.sin(theta),
            z: r * Math.cos(phi)
        };
    }

    // ==========================================
    // 4. LOGIC & INTERACTION STATE
    // ==========================================
    
    let currentShape = 'sphere';
    let baseScale = 1.0;
    let pinchDistance = 0;
    
    // Colors for shapes
    const shapeColors = {
        sphere: { r: 0, g: 1, b: 1 },         // Cyan
        heart: { r: 1, g: 0.1, b: 0.2 },      // Red/Pink
        saturn: { r: 1, g: 0.8, b: 0.2 },     // Gold
        flower: { r: 0.5, g: 0.2, b: 1 },     // Purple
        fireworks: { r: 1, g: 1, b: 1 }       // White (will be randomized)
    };

    function updateShape(shapeName) {
        if (currentShape === shapeName) return;
        currentShape = shapeName;

        const targetColor = shapeColors[shapeName];

        for (let i = 0; i < particleCount; i++) {
            let p;
            
            // Generate Targets
            if (shapeName === 'sphere') p = getSpherePoint(18);
            else if (shapeName === 'heart') p = getHeartPoint(1.2);
            else if (shapeName === 'saturn') p = getSaturnPoint(i);
            else if (shapeName === 'flower') p = getFlowerPoint(i);
            else if (shapeName === 'fireworks') p = getFireworkPoint();
            else p = getSpherePoint(18);

            targetPositions[i * 3] = p.x;
            targetPositions[i * 3 + 1] = p.y;
            targetPositions[i * 3 + 2] = p.z;

            // Set colors based on shape
            if (shapeName === 'fireworks') {
                colors[i*3] = Math.random();
                colors[i*3+1] = Math.random();
                colors[i*3+2] = Math.random();
            } else {
                // Slight variation
                colors[i * 3] = targetColor.r + (Math.random() - 0.5) * 0.2;
                colors[i * 3 + 1] = targetColor.g + (Math.random() - 0.5) * 0.2;
                colors[i * 3 + 2] = targetColor.b + (Math.random() - 0.5) * 0.2;
            }
        }
        
        geometry.attributes.color.needsUpdate = true;
    }

    // Initialize Sphere
    updateShape('sphere');

    // ==========================================
    // 5. MEDIAPIPE HAND TRACKING
    // ==========================================
    const videoElement = document.getElementById('video-input');

    function onResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];

            // 1. GESTURE DETECTION (Simple Finger Counting)
            // Fingertip indices: 8 (Index), 12 (Middle), 16 (Ring), 20 (Pinky)
            // Finger PIP indices (lower joint): 6, 10, 14, 18
            
            const isFingerUp = (tipIdx, pipIdx) => landmarks[tipIdx].y < landmarks[pipIdx].y;
            
            let fingersUp = 0;
            if (isFingerUp(8, 6)) fingersUp++;
            if (isFingerUp(12, 10)) fingersUp++;
            if (isFingerUp(16, 14)) fingersUp++;
            if (isFingerUp(20, 18)) fingersUp++;
            // Thumb logic (x-axis based for right hand/mirrored)
            if (landmarks[4].x < landmarks[3].x) fingersUp++;

            // Map Fingers to Shapes
            if (fingersUp === 1) updateShape('sphere');
            else if (fingersUp === 2) updateShape('heart');
            else if (fingersUp === 3) updateShape('saturn');
            else if (fingersUp === 4) updateShape('flower');
            else if (fingersUp === 5) updateShape('fireworks');

            // 2. PINCH DETECTION (Thumb tip 4, Index tip 8)
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const distance = Math.sqrt(
                Math.pow(thumbTip.x - indexTip.x, 2) + 
                Math.pow(thumbTip.y - indexTip.y, 2)
            );

            // Normalize distance roughly between 0.02 (touching) and 0.2 (spread)
            // Map to scale 0.5 to 2.0
            let targetScale = THREE.MathUtils.mapLinear(distance, 0.02, 0.2, 0.5, 2.5);
            targetScale = THREE.MathUtils.clamp(targetScale, 0.5, 3.0);
            
            // Smoothly interpolate scale
            baseScale += (targetScale - baseScale) * 0.1;

            // 3. ROTATION CONTROL (Hand Center)
            // Wrist is 0, Middle Finger MCP is 9. Approximate center.
            const centerX = landmarks[9].x; // 0 to 1
            const centerY = landmarks[9].y; // 0 to 1
            
            // Map X to rotation Y, Y to rotation X
            // Center of screen (0.5) = 0 rotation
            const rotX = (centerY - 0.5) * 2; 
            const rotY = (centerX - 0.5) * 2;
            
            scene.rotation.x += (rotX - scene.rotation.x) * 0.05;
            scene.rotation.y += (rotY - scene.rotation.y) * 0.05;
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 320,
        height: 240
    });
    cameraUtils.start();

    // ==========================================
    // 6. ANIMATION LOOP
    // ==========================================
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);

        const time = clock.getElapsedTime();
        const positionsArr = geometry.attributes.position.array;

        // MORPHING LOGIC
        // Move current positions towards target positions
        for (let i = 0; i < particleCount; i++) {
            const px = positionsArr[i * 3];
            const py = positionsArr[i * 3 + 1];
            const pz = positionsArr[i * 3 + 2];

            const tx = targetPositions[i * 3] * baseScale;
            const ty = targetPositions[i * 3 + 1] * baseScale;
            const tz = targetPositions[i * 3 + 2] * baseScale;

            // Simple Lerp (Linear Interpolation) for movement
            // Speed factor 0.05
            positionsArr[i * 3]     += (tx - px) * 0.05;
            positionsArr[i * 3 + 1] += (ty - py) * 0.05;
            positionsArr[i * 3 + 2] += (tz - pz) * 0.05;

            // Add some noise/wobble for aliveness
            if (currentShape !== 'saturn') { // Saturn rings look better stable
                positionsArr[i*3] += Math.sin(time + i) * 0.02;
                positionsArr[i*3+1] += Math.cos(time + i) * 0.02;
            }
        }

        geometry.attributes.position.needsUpdate = true;

        // Slow automatic rotation if no hand is detected affecting rotation
        scene.rotation.y += 0.002;

        renderer.render(scene, camera);
    }

    animate();

    // Resize Handler
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>